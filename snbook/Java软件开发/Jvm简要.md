# 0 概述
Java虚拟机(JVM)提供一个统一的java代码执行环境，它可以屏蔽底层不同硬件、操作系统的差异，是实现java跨平台的重要保障。

JVM主要任务就是载入Class文件，然后正确执行Class文件中的指令，最终完成程序的执行。

# 1 JVM规范说明
该部分内容仅仅介绍一个逻辑上的JVM，并不涉及JVM具体实现细节，比如运行时数据区内存布局，垃圾回收算法等。

## 1.1 内存管理机制
Jvm拥有自动内存管理机制，使得程序员不需要再关注内存的分配与释放，大大提高了程序员编码效率。但是，也正是由于程序员没有了对内存操控的权限，一旦出现内存泄露和溢出方面的问题，就需要对Jvm内存管理的相关机制要有详细的了解，才能进一步排查错误。
### 1.1.1 运行时数据区
Jvm运行时，将它拥有的内存分成若干部分，每一部分都有特定的功能。
- 程序计数寄存器：每一个线程都会有一个独立的程序计数寄存器，其内容指向当前被执行的指令。
- Jvm栈：每个线程都有一个独立私有的栈，每个方法调用都会建立一个栈帧，方法调用完毕，栈帧出栈。当线程创建时，同时线程的栈被创建。
- 堆：大部分对象和数组都被分配在堆里，它被所有线程共享，当Jvm启动时，堆区被创建。
- 方法区：方法区类似是一个“存储区域”，也类似于操作系统进程的“代码段”，主要存储类的结构，比如常量池，字段、方法数据，方法和构造方法的代码等。方法区在虚拟机启动的时候创建。
- 本地方法栈：Jvm支持本地方法调用，实现跨语言协作，本地方法栈用来执行本地方法的。

### 1.1.2 常量池
当Jvm加载类或接口时，会为该类或接口创建一个相应的运行时常量池，该常量池分配在Jvm的方法区中。

类或接口的运行时常量池对应的是class文件中常量表，它包含许多编译时就确定的常量，比如常量数据，方法、字段的引用等，它提供一个类似于传统编程语言的符号表的功能。

### 1.1.3 栈帧
栈帧分配在线程的栈里，当一个方法被调用时，就会在栈里相应创建一个新的栈帧，用来存储执行该方法的临时数据，它也负责执行动态链接，返回方法执行的结果，以及分派异常。当方法调用结束(正常结束或异常结束)，栈帧出栈被销毁。

每一个栈帧都有它自己的局部变量表、操作数栈以及指向当前方法的类的常量池引用。

- 局部(本地)变量表：每个栈帧的局部变量表使用数组实现，其大小在编译时就确定了，单局部变量(数组中占一个位置)可以存储基本的数据类型(boolean,byte,char,short,int,float)，引用类型(reference)，或者返回地址(returnAddress，返回到方法调用处)，双局部变量(在数组中占两个位置)通常存储long或者double类型

> 上述可见，jvm规范中，方法执行时，栈帧会将boolean，byte，char，short，int，float全都转换成相同的大小(即局部变量数组单个元素大小，通常为32位)。

> 方法接收的参数会最先存到局部变量表中，从索引0开始。

- 操作数栈：它将常量、本地变量或者类的字段入栈，进行相应运算，运算结果也可以入栈；同时也可以将栈顶数据出栈到本地变量。

- 动态链接：方法在执行过程中，会遇到许多符号引用，这时就需要借助该方法所属类的常量池进行动态链接，将符号引用解析成具体的内存地址。


## 1.2 编译

### 1.2.1 前期编译

### 1.2.2 即时编译

## 1.3 Class文件结构

一个class文件的结构如下：

```java 

ClassFile{
    u4          magic;
    u2          minor_version; u2          major_version;
    u2          constant_pool_count;
    cp_info     constant_pool[constant_pool_count-1];
    u2          access_flags;
    u2          this_class;
    u2          super_class;
    u2          interfaces_count;
    u2          interfaces[interfaces_count];
    u2          fields_count;
    field_info  fields[fields_count];
    u2          methods_count;
    method_info methods[methods_count];
    u2          attributes_count;
    attribute_info attributes[attributes_count];
}
```
- 常量池(constant pool)：常量池主要存储各种编译时确定的信息，比如字符串常量，类、接口名称，字段名称，以及其他常量。每个常量池中的元素都是cp_info类型的。
- 访问标志(access_flags)：访问标志采用掩码的方式进行表示，每一位表示一个访问属性，包括ACC_PUBLIC,ACC_FINAL,ACC_SUPER,ACC_INTERFACE,ACC_ABSTRACT,ACC_SYNTHETIC,ACC_ANNOTATION,ACC_ENUM,ACC_MODULE
- 字段表(fields[])：字段表中的每个表项都是field_info类型的，该表项完整地描述了类或接口的一个字段。
- 方法表(methods[])：如同字段表，它的每个表项都是method_info类型的，该元素完整地描述了类或接口的一个方法。
- 属性集合(attributes[])：属性表内的表项是attribute_info类型的，它描述了类或接口的一些属性，比如内部类列表，源文件名称等信息

> 字段表项(field_info)与方法表项(method_info)中都有相应的属性集合存储字段或方法的一些属性，例如如下两个常见属性：


 - ConstantValue：该属性属于field_info，当字段被`static`修饰时，该属性才起作用，用来存储该字段的值，在类或接口加载过程中被初始化；否则该属性被忽略。
 - Code：该属性属于method_info，它存储了方法的字节码指令。

## 1.4 类加载与执行



### 1.4.1 Jvm的运行时常量池
关于运行时常量池，在[1.1](##1.1)中已经介绍了Jvm的运行时数据区，常量池被分配在方法区中。

同时Jvm的运行时常量池对应的是Class文件中的常量池，在Class文件被加载进Jvm时，依据Class文件的常量池在Jvm中创建相应的常量池。

### 1.4.2 Jvm启动
Jvm通过使用引导类加载器或自定义类加载器创建一个最初的类或接口来启动，然后进行链接，初始化等工作，接着调用`public static void main(String[])`方法。

### 1.4.3 创建与加载


# 2 HotSpot虚拟机
