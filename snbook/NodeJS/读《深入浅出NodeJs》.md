读《深入浅出Nodejs》

久听Node大名，但一直都没接触过，有点闲余，便学习一下，以观其设计思想。起初自然是直奔Node官网，发现还有Node中文网，自然是美滋滋，点击进去一探究竟。找了半天，发现文档都是接口描述，这完全无用啊。折腾半天还是决定找本书看来的实在，百度随手一搜，便搜到了这本《深入浅出NodeJs》，作者为朴灵。看了两篇序言，介绍了作者是国内最早使用并研究的开发者之一，也是国内Node的最早布道者之一，拜读大佬的书。随后便进入正文，其主要介绍了Node前世今生，基础的模块机制，以及核心的异步IO、异步编程等内容。

首先要了解一项技术，那就少不了要了解它的前世今生，它为啥会出现，解决了什么问题以及常见应用场景。Node的创始人Ryan Dahl是一名资深的C/C++程序员，他最初是要设计一个高性能Web服务器，并找了几个关键要点:事件驱动，非阻塞IO。他评估过不少其他语言，最终选定JavaScript，其原因是因为JS具有非常完善的事件驱动的机制，同时关于IO的库非常少，非常利于重新塑造，没有同步IO的包袱。

随后在本书的介绍中，反复强调了Node的几个关键特征，即非阻塞的异步IO，事件与回调函数，单线程，跨平台。而又以异步IO和单线程为主要基调。作为一个典型的习惯了多线程异步，单线程内同步编程的程序员，首次看见将单线程和异步IO并列多少会有些困惑。随着书的展开，上面疑惑迎刃而解，这里的单线程并非指Node是单线程的，Node本身还是多线程的，这里的单线程是指Js的执行是单线程的，这里可以称为主线程，主线程遇到耗时的IO，即将IO操作交给其他线程执行，主线程立即返回后继续执行后续操作，其他线程执行完IO操作后，以事件驱动的方式通知主线程，主线程在空闲时即可处理IO完成后的操作（主要以回调函数的形式实现）。

当Node遇到并发操作时，仍然按照上述过程进行操作，而并非像其他大部分语言那样，遇到并发时，进行多线程处理。Node使用一个单线程来线性处理并发的任务，这样的好处就是不用因为开启一个新的线程并管理其生命周期而消耗额外的资源，而且IO异步处理后，主线程处理每个任务的耗时并不大，大量并发的时候处理速度反而比多线程要快的多。

> 多线程在处理高并发时，很快就因为大量线程的建立和线程调度消耗大量资源，每个线程内都是用同步的阻塞IO的处理方式，每个线程的耗时都比较长。Node的这种方式也有明显的缺点，当并发的多任务的计算任务非常大时，就会因为单个任务的执行阻塞后面的任务。因此，大部分情况下，Node的适用环境是高并发，IO频繁，低计算量的场景，而Web就是一个典型的应用场景。当然，Node仍然可以通过许多办法来降低高计算带来的阻塞，比如使用子进程，计算任务异步处理等。

接下来，就要正式浏览Node的诸多特性了，首先该书介绍了一个基础的模块机制。之前也多多少少写过一些前端代码，对于Js的印象是那种灵活并散碎的感觉，写的代码总是不能很好地复用和维护，而作者在此介绍的模块机制让人一下子就对Js代码的组织有了改观。

Node的模块机制大体遵从CommonJS，由于接触前端不多，这还是第一次听说CommonJS这个规范，大致浏览一遍后，觉得畅快之极。只记得三四年前在某公司实习时，作为一个后端程序员写过些许前端代码，那时用的JS及JQuery，看见前端同事写的一大段一大段的Js文件，我总是尝试给它们拆分成多个文件进行代码模块化，方便阅读和复用，事实上难度还是颇高，最主要的问题就是全局变量分散不同的文件中难以管理，而由于Js代码的载入机制，全局变量又是不可缺少的东西，总之，代码显得臃肿与杂乱。如果使用Node写后端程序，很显然，之前散乱的代码组织方式无法用来编写复杂的后端程序，因此，一个模块机制是非常必要的并且是十分基础的。

Node的模块设计非常简洁与有效，不需要从语言层面上做任何改变，可谓大道至简。其核心思想是将一个js文件作为一个模块，在引入该模块时，将其封装在一个函数里，并进行编译并执行。封装在一个函数里，防止了变量污染，引入时进行编译防止模块中函数内使用的变量的引用丢失，完美地将不同的模块进行隔离。并且，引入模块后会返回一个对象，模块只需要将要暴露的接口存储在该对象中，即可完成模块之间的协作。

随后本书介绍了Node最关键的一个特性，即异步IO。其主要思想就是主线程碰到一个IO操作时，将该操作交给底层的线程去处理，底层的线程处理好之后，形成一个事件等待主线程处理与之相绑定的回调函数。这很明显就是一个事件驱动的编程方式，其关键就是怎么将事件提交给主线程，以及提交的顺序。Node中有一套Event Loop，它采用典型的观察者模式，使用观察者收集事件，然后使用一个循环来不断将观察者中的事件提取出来，将事件绑定的回调函数插入到主线程的执行队列中，等待主线程空闲时执行。Event Loop的每一个循环称为一个Tick，并且每个Tick都有若干阶段，每个阶段处理一种类型的事件，因此就会出现事件处理的优先顺序的问题，这也是编写事件驱动代码需要注意的地方，也是笔试面试最为常见的题目。

> 除了异步IO产生的事件外，Node中还有许多其他事件，比如定时器，服务器的端口监听，自定义事件发生器等。

本书后面还讲解了异步编程，具体为异步编程的优势、难点，并给出了一些解决方案与示例。随后还讲到了V8引擎的内存控制，最后还特别讲解了网络编程及构建Web应用。由于并非需要使用Node进行项目开发，而只是浏览一下Node的风采，因此这次读此书也是浅尝辄止，
虽如此，但也收获颇丰，体验了这样一个生态优秀，事件驱动的异步编程方式，其中种种设计，令人佩服。




