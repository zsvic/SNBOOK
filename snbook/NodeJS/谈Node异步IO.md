Node的基调就是单线程执行与异步IO，其中单线程是指执行JS是以单线程的方式执行，称为主线程。当主线程遇到耗时较大的操作时，如IO操作，可以交给其他线程完成，只要其他线程完成时，将结果返回给主线程即可，这被称为异步IO。

这在低计算，高并发，IO频繁的场景下（典型WEB）具有巨大优势。如此简单而高效的运作方式是怎么实现的呢？这主要分为如下两个主体：
- 请求提交阶段：主线程遇到IO，发起异步调用，将IO操作交给libuv，并携带一个“请求对象”，里面封装了此次调用的相关信息，包括绑定的回调函数
- 处理结果阶段：libuv是Node对接底层系统的一个中间层，libuv利用系统的异步IO进行处理主线程交付的任务，并将执行完的任务所绑定的回调函数交给主线程的执行队列，等待主线程执行，完成整个异步操作。

再进一步，libuv是怎么实现上述过程的呢？libuv主要包括以下几个部分：
- IO接口:包括网络IO，文件IO等
- 系统异步IO模块：包括linux的epoll，Windows的IOCP
- 线程池
  
IO接口接受主线程的异步请求，然后将请求分配给具体系统异步IO模块执行，系统异步IO模块调用线程池执行任务，线程池执行完任务并将结果返回给系统异步IO模块。最后，libuv通过Event loop的方式将系统异步IO模块中处理好的任务提交给主线程。Event loop是一个循环，每一个循环称为一个tick，每一个循环都分为若干阶段，每个阶段都会处理相关的事件，处理相关事件的含义即将相关已完成的任务绑定的回调函数提交给主线程的执行队列，等待主线程空闲时执行。
